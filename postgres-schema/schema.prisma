generator client {
  provider = "prisma-client-js"
  output   = "./generated/postgres"
}

datasource db {
  provider = "postgresql"
  url      = env("POSTGRESQL_DATABASE_URL")
}

// Appointment for a company.
model Appointment {
  id                              Int               @id @default(autoincrement())
  userId                          Int               @map("user_id")
  title                           String            @db.VarChar(100)
  date                            DateTime?
  startTime                       String?           @map("start_time")
  endTime                         String?           @map("end_time")
  companyId                       Int               @map("company_id")
  clientId                        Int?              @map("customer_id")
  vehicleId                       Int?              @map("vehicle_id")
  draftEstimate                   String?           @map("draft_estimate")
  notes                           String?
  confirmationEmailTemplateId     Int?              @map("confirmation_email_template_id")
  confirmationEmailTemplateStatus Boolean           @default(false) @map("confirmation_email_template_status")
  reminderEmailTemplateId         Int?              @map("reminder_email_template_id")
  reminderEmailTemplateStatus     Boolean           @default(false) @map("reminder_email_template_status")
  times                           Json? // { time: string; date: string }
  createdAt                       DateTime          @default(now()) @map("created_at")
  updatedAt                       DateTime          @default(now()) @updatedAt @map("updated_at")
  user                            User              @relation(fields: [userId], references: [id])
  company                         Company           @relation(fields: [companyId], references: [id], onDelete: Cascade)
  appointmentUsers                AppointmentUser[]
  client                          Client?           @relation(fields: [clientId], references: [id])
  vehicle                         Vehicle?          @relation(fields: [vehicleId], references: [id])
  googleEventId                   String?
  timezone                        String?

  @@index([userId], name: "fk_tasks_user")
  @@index([companyId], name: "fk_tasks_company")
  @@index([clientId], name: "fk_tasks_client")
  @@index([date])
}

// Assigned user for an appointment.
model AppointmentUser {
  id            Int         @id @default(autoincrement())
  appointmentId Int         @map("appointment_id")
  userId        Int         @map("user_id")
  eventId       String      @db.VarChar(100)
  createdAt     DateTime    @default(now()) @map("created_at")
  updatedAt     DateTime    @default(now()) @updatedAt @map("updated_at")
  appointment   Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([appointmentId])
}

// Pipeline Automation Schema

model PipelineAutomationRule {
  id             Int             @id @default(autoincrement())
  title          String
  stages         PipelineStage[] // Stages where the rule applies (can select multiple)
  conditionType  ConditionType
  targetColumnId Int? // Target column/stage where lead will move to
  targetColumn   Column?         @relation(fields: [targetColumnId], references: [id], name: "targetColumn")
  isPaused       Boolean         @default(false)
  timeDelay      Int? // in seconds
  companyId      Int
  company        Company         @relation(fields: [companyId], references: [id], onDelete: Cascade)
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt

  // Related models
  timeDelayExecutions TimeDelayExecution[]

  @@index([companyId])
}

model PipelineStage {
  id             Int                    @id @default(autoincrement())
  pipelineRuleId Int
  columnId       Int
  pipelineRule   PipelineAutomationRule @relation(fields: [pipelineRuleId], references: [id], onDelete: Cascade)
  column         Column                 @relation(fields: [columnId], references: [id], onDelete: Cascade)

  @@unique([pipelineRuleId, columnId])
  @@index([pipelineRuleId])
}

model TimeDelayExecution {
  id                       Int                               @id @default(autoincrement())
  pipelineRuleId           Int?
  communicationRuleId      Int?
  leadId                   Int?
  estimateId               String?
  serviceMaintenanceRuleId Int?
  lead                     Lead?                             @relation(fields: [leadId], references: [id], onDelete: Cascade)
  estimate                 Invoice?                          @relation(fields: [estimateId], references: [id], onDelete: Cascade)
  executeAt                DateTime
  status                   ExecutionStatus                   @default(PENDING)
  jobId                    String?
  createdAt                DateTime                          @default(now())
  updatedAt                DateTime                          @updatedAt
  columnId                 Int?
  column                   Column?                           @relation(fields: [columnId], references: [id])
  pipelineRule             PipelineAutomationRule?           @relation(fields: [pipelineRuleId], references: [id], onDelete: SetNull)
  communicationRule        CommunicationAutomationRule?      @relation(fields: [communicationRuleId], references: [id], onDelete: SetNull)
  serviceMaintenanceRule   ServiceMaintenanceAutomationRule? @relation(fields: [serviceMaintenanceRuleId], references: [id], onDelete: SetNull)

  @@index([executeAt, status])
  @@index([pipelineRuleId])
  @@index([communicationRuleId])
  @@index([leadId])
}

model CommunicationAutomationRule {
  id                 Int                    @id @default(autoincrement())
  companyId          Int
  title              String
  stages             CommunicationStage[]
  timeDelay          Int
  targetColumnId     Int? // Target column/stage where lead will move to
  communicationType  CommunicationType
  isSendWeekDays     Boolean                @default(false)
  templateType       TemplateType
  subject            String?
  emailBody          String?                @db.Text
  smsBody            String?                @db.Text
  isPaused           Boolean                @default(false)
  createdBy          String?
  attachments        AutomationAttachment[] @relation("CommunicationAttachments")
  createdAt          DateTime               @default(now())
  updatedAt          DateTime               @updatedAt
  targetColumn       Column?                @relation(fields: [targetColumnId], references: [id], name: "targetColumn")
  timeDelayExecution TimeDelayExecution[]
}

model CommunicationStage {
  id                  Int                         @id @default(autoincrement())
  communicationRuleId Int
  columnId            Int
  communicationRule   CommunicationAutomationRule @relation(fields: [communicationRuleId], references: [id], onDelete: Cascade)
  column              Column                      @relation(fields: [columnId], references: [id], onDelete: Cascade)

  @@unique([communicationRuleId, columnId])
  @@index([communicationRuleId])
}

model MarketingAutomationRule {
  id                   Int                    @id @default(autoincrement())
  companyId            Int
  target               Json
  targetCondition      TargetCondition
  date                 DateTime
  startTime            DateTime
  isAppointmentCreated Boolean                @default(false)
  vehicleMinYear       String?
  vehicleMaxYear       String?
  vehicleBrand         String?
  vehicleModel         String?
  communicationType    CommunicationType
  emailSubject         String?
  emailBody            String?                @db.Text
  smsBody              String?                @db.Text
  isPaused             Boolean                @default(false)
  createdBy            String
  isActive             Boolean                @default(true)
  attachments          AutomationAttachment[] @relation("MarketingAttachments")
  createdAt            DateTime               @default(now())
  updatedAt            DateTime               @updatedAt
}

model ServiceMaintenanceAutomationRule {
  id                      Int                       @id @default(autoincrement())
  companyId               Int
  title                   String
  conditionColumnId       Int
  isPaused                Boolean                   @default(false)
  timeDelay               Int? // in seconds
  targetColumnId          Int?
  templateType            TemplateType              @default(SMS)
  emailSubject            String?
  emailBody               String?                   @db.Text
  smsBody                 String?                   @db.Text
  createdBy               String?
  createdAt               DateTime                  @default(now())
  updatedAt               DateTime                  @updatedAt
  company                 Company                   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  targetColumn            Column?                   @relation(fields: [targetColumnId], references: [id], name: "targetColumn")
  attachments             AutomationAttachment[]    @relation("ServiceMaintenanceAttachments")
  conditionColumn         Column?                   @relation(fields: [conditionColumnId], references: [id], name: "conditionColumn")
  serviceMaintenanceStage ServiceMaintenanceStage[]
  timeDelayExecution      TimeDelayExecution[]
}

model ServiceMaintenanceStage {
  id                       Int                              @id @default(autoincrement())
  serviceMaintenanceRuleId Int
  serviceId                Int
  serviceMaintenanceRule   ServiceMaintenanceAutomationRule @relation(fields: [serviceMaintenanceRuleId], references: [id], onDelete: Cascade)
  service                  Service                          @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  columnId                 Int?

  @@unique([serviceMaintenanceRuleId, serviceId])
  @@index([serviceMaintenanceRuleId])
}

model InvoiceAutomationRule {
  id                Int                    @id @default(autoincrement())
  title             String
  companyId         Int
  invoiceStatus     String
  timeDelay         Int?
  isPaused          Boolean                @default(false)
  communicationType CommunicationType
  emailBody         String
  smsBody           String
  emailSubject      String
  attachments       AutomationAttachment[] @relation("InvoiceAttachments")
  company           Company                @relation(fields: [companyId], references: [id], onDelete: Cascade)
}

model AutomationAttachment {
  id                   Int                               @id @default(autoincrement())
  fileUrl              String
  communicationId      Int?
  marketingId          Int?
  serviceMaintenanceId Int?
  invoiceId            Int?
  communication        CommunicationAutomationRule?      @relation("CommunicationAttachments", fields: [communicationId], references: [id])
  marketing            MarketingAutomationRule?          @relation("MarketingAttachments", fields: [marketingId], references: [id])
  serviceMaintenance   ServiceMaintenanceAutomationRule? @relation("ServiceMaintenanceAttachments", fields: [serviceMaintenanceId], references: [id])
  invoice              InvoiceAutomationRule?            @relation("InvoiceAttachments", fields: [invoiceId], references: [id])
  createdAt            DateTime                          @default(now())
  updatedAt            DateTime                          @updatedAt
}

// Enums
enum CommunicationType {
  SMS
  EMAIL
  BOTH
}

enum TemplateType {
  SMS
  EMAIL
}

enum MarketingTarget {
  ALL_CLIENTS
  WITH_ESTIMATE
  WITH_INVOICE
  WITHOUT_AN_ESTIMATE
  INVOICE
}

enum TargetCondition {
  ALL_CLIENTS_THIS_MONTH
  ALL_CLIENTS_THIS_YEAR
  ALL_CLIENTS_FROM_1_MONTH
  ALL_CLIENTS_FROM_2_MONTHS
  ALL_CLIENTS_FROM_3_MONTHS
  ALL_CLIENTS_FROM_6_MONTHS
  ALL_CLIENTS_FROM_LAST_YEAR
}

enum ConditionType {
  APPOINTMENT_SCHEDULED
  ESTIMATE_CREATED
  TASK_CREATED
  MESSAGE_SENT_CLIENT
  MESSAGE_RECEIVED_CLIENT
  TIME_DELAY
}

enum ExecutionStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
}

// Client of a company.
// Client is just data, they can't login.
model Client {
  id                     Int                      @id @default(autoincrement())
  firstName              String                   @map("first_name")
  lastName               String?                  @map("last_name")
  mobile                 String?
  email                  String?
  address                String?
  city                   String?
  state                  String?
  zip                    String?
  isFleet                Boolean?                 @default(false) @map("is_fleet")
  photo                  String                   @default("/images/default.png")
  fromRequest            Boolean?                 @default(false) @map("from_request")
  fromRequestedCompanyId Int?                     @map("from_requested_company_id")
  sourceId               Int?                     @map("source_id")
  converted              Boolean?                 @default(false) @map("converted")
  companyId              Int                      @map("company_id")
  createdAt              DateTime                 @default(now()) @map("created_at")
  updatedAt              DateTime                 @default(now()) @updatedAt @map("updated_at")
  company                Company                  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  customerCompany        String?                  @map("customer_company")
  tagId                  Int?                     @map("tag_id")
  notes                  String?
  conversationsTrack     ClientConversationTrack?
  appointments           Appointment[]
  source                 Source?                  @relation(fields: [sourceId], references: [id])
  tag                    Tag?                     @relation(fields: [tagId], references: [id])
  Vehicle                Vehicle[]
  Invoice                Invoice[]
  ClientCoupon           ClientCoupon[]
  Task                   Task[]
  ClientSMS              ClientSMS[]
  ClientCall             ClientCall[]
  leadId                 Int?
  Lead                   Lead?                    @relation(fields: [leadId], references: [id])
  MailgunEmail           MailgunEmail[]
  firstContactTime       DateTime?
  lastMailgunEmailReadId Int?
  isStarred              Boolean?                 @default(false)
  fleet                  Fleet?

  @@index([companyId], name: "fk_customers_company")
  @@map("Client")
}

model Fleet {
  id                   Int              @id @default(autoincrement())
  clientId             Int              @unique @map("client_id")
  fleetName            String
  contactName          String
  preferredPaymentTerm String?          @map("preferred_payment_term")
  createdAt            DateTime         @default(now()) @map("created_at")
  updatedAt            DateTime         @default(now()) @updatedAt @map("updated_at")
  client               Client           @relation(fields: [clientId], references: [id], onDelete: Cascade)
  statement            FleetStatement[]
}

model FleetStatement {
  id        String    @id @default(cuid())
  fleetId   Int       @map("fleet_id")
  Fleet     Fleet     @relation(fields: [fleetId], references: [id])
  invoice   Invoice[]
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @default(now()) @updatedAt @map("updated_at")
}

model Source {
  id        Int      @id @default(autoincrement())
  name      String
  companyId Int      @map("company_id")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")
  company   Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  Client    Client[]
}

model ClientCoupon {
  id        Int      @id @default(autoincrement())
  couponId  Int      @map("coupon_id")
  clientId  Int      @map("client_id")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")
  coupon    Coupon   @relation(fields: [couponId], references: [id], onDelete: Cascade)
  client    Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
}

model ClientConversationTrack {
  id                 Int       @id @default(autoincrement())
  clientId           Int       @unique @map("client_id") // Add unique constraint to establish the one-to-one relation
  emailIsRead        Boolean   @default(true) @map("email_is_read")
  smsIsRead          Boolean   @default(true) @map("sms_is_read")
  emailIsUnReadCount Int       @default(0) @map("email_is_unread_count")
  smsUnReadCount     Int       @default(0) @map("sms_unread_count")
  emailLastMessage   String    @default("no message") @map("email_last_message")
  smsLastMessage     String    @default("no message") @map("sms_last_message")
  sendAt             DateTime? @map("send_at")
  createdAt          DateTime  @default(now()) @map("created_at")
  updatedAt          DateTime  @default(now()) @updatedAt @map("updated_at")
  client             Client    @relation(fields: [clientId], references: [id], onDelete: Cascade) // Update this line to establish the one-to-one relation
}

// Company model.
// Every user belongs to a company.
// For now, every user has to create their own company when registering.
// In the future, we can add a feature to join a company.
model Company {
  id                               Int                                @id @default(autoincrement())
  name                             String
  businessId                       String?                            @map("business_id")
  businessType                     String?                            @map("business_type")
  phone                            String?
  email                            String?
  industry                         String?
  website                          String?
  address                          String?
  city                             String?
  state                            String?
  zip                              String?
  image                            String?
  businessVisibility               Boolean?                           @default(true) @map("business_visibility")
  phoneVisibility                  Boolean?                           @default(true) @map("phone_visibility")
  addressVisibility                Boolean?                           @default(true) @map("address_visibility")
  tax                              Decimal?                           @default(0)
  serviceFee                       Decimal?                           @default(0)
  currency                         String?                            @default("USD")
  terms                            String?                            @db.VarChar(800)
  policy                           String?                            @db.VarChar(800)
  googleEmail                      String?                            @map("google_email")
  googleRefreshToken               String?                            @map("google_refresh_token")
  googleCalendarToken              String?                            @map("google_calendar_token")
  createdAt                        DateTime                           @default(now()) @map("created_at")
  updatedAt                        DateTime                           @default(now()) @updatedAt @map("updated_at")
  companyLatitude                  Float?
  companyLongitude                 Float?
  zapierToken                      String?                            @unique @db.VarChar(240)
  users                            User[]
  tasks                            Task[]
  clients                          Client[]
  services                         Service[]
  vehicles                         Vehicle[]
  invoices                         Invoice[]
  calendarSettings                 CalendarSettings[]
  appointments                     Appointment[]
  emailTemplates                   EmailTemplate[]
  materials                        Material[]
  vendors                          Vendor[]
  labors                           Labor[]
  tags                             Tag[]
  categories                       Category[]
  statuses                         Status[]
  paymentMethods                   PaymentMethod[]
  inventoryProducts                InventoryProduct[]
  VehicleColor                     VehicleColor[]
  Source                           Source[]
  Payment                          Payment[]
  Coupon                           Coupon[]
  Technician                       Technician[]
  companyJoinsAsOne                CompanyJoin[]                      @relation("CompanyOne")
  companyJoinsAsTwo                CompanyJoin[]                      @relation("CompanyTwo")
  companyEmailTemplate             CompanyEmailTemplate[]
  permissionForManager             PermissionForManager[]
  permissionForSales               PermissionForSales[]
  permissionForTechnician          PermissionForTechnician[]
  permissionForOther               PermissionForOther[]
  permissions                      Permission[]
  Lead                             Lead[]
  isCRMEnabled                     Boolean?                           @default(false) @map("is_crm_enabled")
  LeaveRequest                     LeaveRequest[]
  RequestEstimateSent              RequestEstimate[]                  @relation("SenderCompany")
  RequestEstimateReceived          RequestEstimate[]                  @relation("ReceiverCompany")
  Column                           Column[]
  ClockInOut                       ClockInOut[]
  Holiday                          Holiday[]
  InventoryProductHistory          InventoryProductHistory[]
  UserFeedback                     UserFeedback[]
  ClientSMS                        ClientSMS[]
  ClientCall                       ClientCall[]
  TwilioCredentials                TwilioCredentials?                 @relation(fields: [twilioCredentialsId], references: [id])
  twilioCredentialsId              Int?
  MailgunCredential                MailgunCredential?                 @relation(fields: [mailgunCredentialId], references: [id])
  mailgunCredentialId              Int?
  MailgunEmail                     MailgunEmail[]
  NotificationSettings             NotificationSettingsV2[]
  Notification                     Notification[]
  stripeAccountId                  String?
  timezone                         String?
  stripePayment                    StripePayment[]
  leadLink                         LeadLink[]
  PipelineAutomationRule           PipelineAutomationRule[]
  ServiceMaintenanceAutomationRule ServiceMaintenanceAutomationRule[]
  Refund                           Refund[]

  InvoiceAutomationRule InvoiceAutomationRule[]
}

// create model that will handle multiple companies join and collaboration
model CompanyJoin {
  id           Int      @id @default(autoincrement())
  companyOneId Int
  companyTwoId Int
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @default(now()) @updatedAt @map("updated_at")
  companyOne   Company  @relation(fields: [companyOneId], references: [id], onDelete: Cascade, name: "CompanyOne")
  companyTwo   Company  @relation(fields: [companyTwoId], references: [id], onDelete: Cascade, name: "CompanyTwo")
}

// Calendar settings for a company.
model CalendarSettings {
  id        Int      @id @default(autoincrement())
  companyId Int      @unique @map("company_id")
  weekStart String
  dayStart  String
  dayEnd    String
  weekend1  String   @default("Saturday")
  weekend2  String   @default("Sunday")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")
  company   Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
}

model Holiday {
  id        Int      @id @default(autoincrement())
  companyId Int      @map("company_id")
  date      DateTime
  month     String
  year      Int
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")
  company   Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([month])
  @@index([year])
}

// Email template for a company.
model EmailTemplate {
  id        Int               @id @default(autoincrement())
  subject   String
  message   String?           @db.Text
  type      EmailTemplateType
  companyId Int               @map("company_id")
  createdAt DateTime          @default(now()) @map("created_at")
  updatedAt DateTime          @default(now()) @updatedAt @map("updated_at")
  company   Company           @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
}

enum EmailTemplateType {
  Confirmation
  Reminder
}

model Lead {
  id                  Int        @id @default(autoincrement())
  clientName          String     @map("client_name")
  clientEmail         String?    @map("client_email")
  clientPhone         String?    @map("client_phone")
  vehicleInfo         String     @map("vehicle_info")
  vehicleId           Int?
  services            String
  source              String
  comments            String?
  companyId           Int        @map("company_id")
  createdAt           DateTime   @default(now()) @map("created_at")
  updatedAt           DateTime   @default(now()) @updatedAt @map("updated_at")
  columnChangedAt     DateTime?  @map("column_changed_at")
  company             Company    @relation(fields: [companyId], references: [id], onDelete: Cascade)
  columnId            Int?       @map("column_id")
  column              Column?    @relation(fields: [columnId], references: [id], onDelete: Cascade)
  assignedSalesUserId Int?       @map("assigned_sales_id")
  assignedDate        DateTime?  @map("assigned_date")
  salesUser           User?      @relation(fields: [assignedSalesUserId], references: [id], onDelete: Cascade)
  isLead              Boolean    @default(true)
  isQualified         Boolean    @default(true)
  isEstimateCreated   Boolean?   @default(false)
  tasks               Task[]
  leadTags            LeadTags[]
  serviceId           Int?
  Service             Service?   @relation(fields: [serviceId], references: [id])

  Client              Client[]
  TimeDelayExecutions TimeDelayExecution[]

  @@index([serviceId])
  @@index([vehicleId])
  @@index([columnId])
  @@index([companyId])
  @@index([assignedSalesUserId])
  @@index([clientEmail])
  @@index([columnChangedAt])
  @@index([isEstimateCreated])
  @@index([createdAt])
  @@index([companyId, columnId])
}

model LeadTags {
  id        Int      @id @default(autoincrement())
  leadId    Int      @map("lead_id")
  tagId     Int      @map("tag_id")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  lead Lead @relation(fields: [leadId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@index([leadId], name: "fk_lead_tags_lead")
  @@index([tagId], name: "fk_lead_tags_tag")
}

model LeadLink {
  id            Int      @id @default(autoincrement())
  source        String
  generatedLink String   @db.Text
  shortUrl      String?
  QRCode        String?  @db.Text
  companyId     Int?
  company       Company? @relation(fields: [companyId], references: [id])
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @default(now()) @updatedAt @map("updated_at")

  @@unique([source, companyId, shortUrl], name: "unique_lead_link_per_company")
  @@index([companyId])
}

model LeaveRequest {
  id          Int                @id @default(autoincrement())
  userId      Int                @map("user_id")
  startDate   DateTime           @map("start_date")
  endDate     DateTime           @map("end_date")
  status      LeaveRequestStatus
  title       String
  description String
  companyId   Int                @map("company_id")
  createdAt   DateTime           @default(now()) @map("created_at")
  updatedAt   DateTime           @default(now()) @updatedAt @map("updated_at")
  user        User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  company     Company            @relation(fields: [companyId], references: [id], onDelete: Cascade)
}

enum LeaveRequestStatus {
  Pending
  Approved
  Rejected
}

// TODO: this might need to be renamed
model CompanyEmailTemplate {
  id        Int      @id @default(autoincrement())
  subject   String
  message   String?  @db.Text
  companyId Int      @map("company_id")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")
  company   Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@map("companyEmailTemplate")
}

model TwilioCredentials {
  id Int @id @default(autoincrement())

  accountSid     String  @map("account_sid")
  authToken      String  @map("auth_token")
  phoneNumber    String  @map("phone_number")
  apiKeySid      String  @map("api_key_sid")
  apiKeySecret   String  @map("api_key_secret")
  twimlAppSid    String? @map("twiml_app_sid")
  phoneNumberSid String  @map("phone_number_sid")
  companyId      Int     @unique @map("company_id")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  Company Company[]
}

model MailgunCredential {
  id                 Int                       @id @default(autoincrement())
  companyId          Int
  mailAddress        String?
  domain             String
  apiKey             String?
  smtpPassword       String?
  dnsRecords         Json?
  isVerified         Boolean                   @default(false)
  verificationStatus MailgunVerificationStatus @default(pending) // Use an enum if possible
  company            Company[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([companyId, domain]) // Ensures a user cannot have duplicate domains
}

enum MailgunVerificationStatus {
  pending
  verified
  failed
}

model MailgunEmail {
  id Int @id @default(autoincrement())

  subject     String
  text        String                   
  attachments MailgunEmailAttachment[]
  emailBy     EMAIL_BY

  messageId String?

  companyId Int
  company   Company @relation(fields: [companyId], references: [id])

  clientId Int
  client   Client @relation(fields: [clientId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
}

enum EMAIL_BY {
  Client
  Company
}

model MailgunEmailAttachment {
  id Int @id @default(autoincrement())

  name String
  url  String
  size Int

  mailgunEmailId Int
  mailgunEmail   MailgunEmail @relation(fields: [mailgunEmailId], references: [id], onDelete: Cascade)
}

// Category of a invoice.
// Category is a part of Service, Material and Labor.
// It's an independant model. So, one category can be in multiple services, materials and labors.
model Category {
  id                Int                @id @default(autoincrement())
  name              String
  companyId         Int                @map("company_id")
  createdAt         DateTime           @default(now()) @map("created_at")
  updatedAt         DateTime           @default(now()) @updatedAt @map("updated_at")
  services          Service[]
  materials         Material[]
  labors            Labor[]
  inventoryProducts InventoryProduct[]
  company           Company            @relation(fields: [companyId], references: [id], onDelete: Cascade)
}

// Status of a invoice.
// Status is an independant model. So, one status can be in multiple invoices.
model Status {
  id        Int       @id @default(autoincrement())
  name      String
  textColor String // hex (with #)
  bgColor   String // hex (with #)
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @default(now()) @updatedAt @map("updated_at")
  companyId Int       @map("company_id")
  company   Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  Invoice   Invoice[]
}

enum Priority {
  Low
  Medium
  High
}

// Updated Column model with fixed relations

model Column {
  id        Int     @id @default(autoincrement())
  title     String
  type      String // "sales" or "shop"
  order     Int
  textColor String?
  bgColor   String?
  companyId Int     @map("company_id")

  company  Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  invoices Invoice[]
  lead     Lead[]

  // Relations for pipeline automation
  pipelineStages                   PipelineStage[]
  communicationStage               CommunicationStage[]
  timeDelayExecutions              TimeDelayExecution[]
  targetForRules                   PipelineAutomationRule[]           @relation("targetColumn")
  targetForCommunicationRules      CommunicationAutomationRule[]      @relation("targetColumn")
  serviceMaintenanceAutomationRule ServiceMaintenanceAutomationRule[] @relation("targetColumn")
  serviceMaintenanceStageForRules  ServiceMaintenanceAutomationRule[] @relation("conditionColumn")

  @@index([companyId])
  @@index([type])
  @@index([type, companyId])
}

model InventoryProduct {
  id                      Int                       @id @default(autoincrement())
  name                    String
  description             String?                   @db.Text
  categoryId              Int?                      @map("category_id")
  quantity                Decimal?                  @default(1) @db.Decimal(10, 2)
  price                   Decimal?                  @default(0)
  unit                    String?                   @default("pc")
  lot                     String?
  vendorId                Int?                      @map("vendor_id")
  userId                  Int?                      @map("user_id")
  User                    User?                     @relation(fields: [userId], references: [id], onDelete: SetNull)
  type                    InventoryProductType
  receipt                 String?
  lowInventoryAlert       Int?                      @map("low_inventory_alert")
  companyId               Int                       @map("company_id")
  createdAt               DateTime                  @default(now()) @map("created_at")
  updatedAt               DateTime                  @default(now()) @updatedAt @map("updated_at")
  company                 Company                   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  category                Category?                 @relation(fields: [categoryId], references: [id])
  vendor                  Vendor?                   @relation(fields: [vendorId], references: [id], onDelete: SetNull)
  InventoryProductHistory InventoryProductHistory[]
  Material                Material[]
  tags                    InventoryProductTag[]
}

model InventoryProductTag {
  inventoryId Int              @map("inventory_id")
  tagId       Int              @map("tag_id")
  inventory   InventoryProduct @relation(fields: [inventoryId], references: [id], onDelete: Cascade)
  tag         Tag              @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([inventoryId, tagId])
}

model InventoryProductHistory {
  id        Int                         @id @default(autoincrement())
  price     Decimal?                    @default(0)
  quantity  Decimal                     @db.Decimal(10, 2)
  date      DateTime?                   @default(now())
  notes     String?
  type      InventoryProductHistoryType
  productId Int                         @map("inventory_id")
  invoiceId String?                     @map("invoice_id")
  vendorId  Int?                        @map("vendor_id")
  createdAt DateTime                    @default(now()) @map("created_at")
  updatedAt DateTime                    @default(now()) @updatedAt @map("updated_at")
  isLost    Boolean?                    @default(false) @map("is_lost")
  product   InventoryProduct            @relation(fields: [productId], references: [id], onDelete: Cascade)
  invoice   Invoice?                    @relation(fields: [invoiceId], references: [id])
  vendor    Vendor?                     @relation(fields: [vendorId], references: [id], onDelete: SetNull)
  companyId Int                         @map("company_id")
  company   Company                     @relation(fields: [companyId], references: [id], onDelete: Cascade)
}

enum InventoryProductHistoryType {
  Purchase
  Sale
}

enum InventoryProductType {
  Supply
  Product
}

// Vendor of a company.
// Vendor is just data, they can't login.
// Vendor is a part of Material.
model Vendor {
  id                      Int                       @id @default(autoincrement())
  name                    String?
  website                 String?
  email                   String?
  phone                   String?
  address                 String?
  city                    String?
  state                   String?
  zip                     String?
  // company name for vendor. Its not related to company model.
  companyName             String
  notes                   String?
  companyId               Int                       @map("company_id")
  createdAt               DateTime                  @default(now()) @map("created_at")
  updatedAt               DateTime                  @default(now()) @updatedAt @map("updated_at")
  company                 Company                   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  material                Material[]
  inventoryProducts       InventoryProduct[]
  InventoryProductHistory InventoryProductHistory[]
}

model inventoryWirehouseProduct {
  id          Int    @id @default(autoincrement())
  productName String @unique
  category    String
  unit        String

  @@index([productName])
  @@index([category])
  @@index([unit])
  @@index([category, productName])
}

// InvoiceItem of a invoice.
// Its a holder for service, material and labor.
// One invoice can have multiple InvoiceItems.
// And one InvoiceItem can have one service, material and labor.
// Its dependant on invoice. So, invoiceItem can't be in multiple invoices.
model InvoiceItem {
  id          Int          @id @default(autoincrement())
  invoiceId   String?      @map("invoice_id")
  serviceId   Int?         @map("service_id")
  laborId     Int?         @map("labor_id")
  createdAt   DateTime     @default(now()) @map("created_at")
  updatedAt   DateTime     @default(now()) @updatedAt @map("updated_at")
  invoice     Invoice?     @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  service     Service?     @relation(fields: [serviceId], references: [id])
  labor       Labor?       @relation(fields: [laborId], references: [id])
  serviceDesc String?      @map("service_desc")
  materials   Material[]
  tags        ItemTag[]
  technicians Technician[]
}

enum InvoiceItemMaterialType {
  Material
  Product
}

// Service of a invoice.
// Service is a part of InvoiceItem.
// One invoice can have multiple InvoiceItems.
// And one InvoiceItem can have one service.
// Service itself is an independant model, So one service can be in multiple invoices.
// And if you want to fetch services for a client, you need to fetch all invoices and then all invoice items and then you'll get services.
model Service {
  id                      Int                       @id @default(autoincrement())
  createdAt               DateTime                  @default(now()) @map("created_at")
  updatedAt               DateTime                  @default(now()) @updatedAt @map("updated_at")
  name                    String
  description             String?
  canned                  Boolean?                  @default(false)
  fromRequest             Boolean?                  @default(false) @map("from_request")
  fromRequestedCompanyId  Int?                      @map("from_requested_company_id")
  categoryId              Int?                      @map("category_id")
  companyId               Int                       @map("company_id")
  vehicleParts            VehicleParts[]
  company                 Company                   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  category                Category?                 @relation(fields: [categoryId], references: [id])
  invoiceItems            InvoiceItem[]
  Technician              Technician[]
  requestEstimate         RequestEstimate?          @relation("Service")
  InvoiceRedo             InvoiceRedo[]
  Lead                    Lead[]
  ServiceMaintenanceStage ServiceMaintenanceStage[]

  @@index([companyId], name: "fk_services_company")
}

// Material of a invoice.
// Material is a part of InvoiceItem.
// One invoice can have multiple InvoiceItems.
// And one InvoiceItem can have one material.
// Material itself is an independant model, So one material can be in multiple invoices.
// And if you want to fetch materials for a client, you need to fetch all invoices and then all invoice items and then you'll get materials.
model Material {
  id            Int               @id @default(autoincrement())
  name          String
  vendorId      Int?              @map("vendor_id")
  categoryId    Int?              @map("category_id")
  notes         String?
  quantity      Decimal?          @db.Decimal(10, 2)
  cost          Decimal?
  sell          Decimal?
  discount      Decimal?
  companyId     Int               @map("company_id")
  invoiceId     String?           @map("invoice_id")
  invoiceItemId Int?              @map("invoice_item_id")
  productId     Int?              @map("product_id")
  createdAt     DateTime          @default(now()) @map("created_at")
  updatedAt     DateTime          @default(now()) @updatedAt @map("updated_at")
  company       Company           @relation(fields: [companyId], references: [id], onDelete: Cascade)
  vendor        Vendor?           @relation(fields: [vendorId], references: [id], onDelete: SetNull)
  category      Category?         @relation(fields: [categoryId], references: [id])
  invoiceItem   InvoiceItem?      @relation(fields: [invoiceItemId], references: [id], onDelete: Cascade)
  product       InventoryProduct? @relation(fields: [productId], references: [id])
  invoice       Invoice?          @relation(fields: [invoiceId], references: [id])
  tags          MaterialTag[]

  @@index([companyId], name: "fk_materials_company")
}

// Labor of a invoice.
// Labor is a part of InvoiceItem.
// One invoice can have multiple InvoiceItems.
// And one InvoiceItem can have one labor.
// Labor itself is an independant model, So one labor can be in multiple invoices.
// And if you want to fetch labors for a customer, you need to fetch all invoices and then all invoice items and then you'll get labors.
model Labor {
  id           Int           @id @default(autoincrement())
  name         String
  categoryId   Int?          @map("category_id")
  notes        String?
  hours        Decimal?      @db.Decimal(13, 3)
  charge       Decimal?
  discount     Decimal?
  companyId    Int           @map("company_id")
  cannedLabor  Boolean?      @default(false) @map("canned_labor")
  createdAt    DateTime      @default(now()) @map("created_at")
  updatedAt    DateTime      @default(now()) @updatedAt @map("updated_at")
  company      Company       @relation(fields: [companyId], references: [id], onDelete: Cascade)
  category     Category?     @relation(fields: [categoryId], references: [id])
  invoiceItems InvoiceItem[]
  tags         LaborTag[]
  // @@unique([name, companyId], name: "name_companyId")
}

// Tag for a invoice.
// Tag is a part of InvoiceItem, Material and Labor.
// One invoice can have multiple InvoiceItems.
// And one InvoiceItem, Material and Labor can have multiple tags.
// Tag itself is an independant model, So one tag can be in multiple invoices.
model Tag {
  id                  Int                   @id @default(autoincrement())
  name                String
  textColor           String // hex (with #)
  bgColor             String // hex (with #)
  type                TagType               @default(GENERAL) //Tag type to distinguish between sales, client, etc.
  createdAt           DateTime              @default(now()) @map("created_at")
  updatedAt           DateTime              @default(now()) @updatedAt @map("updated_at")
  companyId           Int                   @map("company_id")
  company             Company               @relation(fields: [companyId], references: [id], onDelete: Cascade)
  items               ItemTag[]
  materials           MaterialTag[]
  labors              LaborTag[]
  Client              Client[]
  InvoiceTags         InvoiceTags[]
  InventoryProductTag InventoryProductTag[]
  leadTags            LeadTags[]

  @@index([companyId, type]) // NEW: Index for better query performance
}

// Many to many relation between Item and Tag.
model ItemTag {
  itemId Int
  tagId  Int
  item   InvoiceItem @relation(fields: [itemId], references: [id], onDelete: Cascade)
  tag    Tag         @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([itemId, tagId])
}

// Many to many relation between Material and Tag.
model MaterialTag {
  materialId Int      @map("material_id")
  tagId      Int      @map("tag_id")
  material   Material @relation(fields: [materialId], references: [id], onDelete: Cascade)
  tag        Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([materialId, tagId])
}

// Many to many relation between Labor and Tag.
model LaborTag {
  laborId Int   @map("labor_id")
  tagId   Int   @map("tag_id")
  labor   Labor @relation(fields: [laborId], references: [id], onDelete: Cascade)
  tag     Tag   @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([laborId, tagId])
}

// NEW: Enum for tag types
enum TagType {
  GENERAL // For invoice items, materials, labor
  SALES // For sales/leads
  CLIENT // For clients
  INVENTORY // For inventory products
}

// Invoice of a company.
// Note that `Invoice` is same as `Estimate`. So don't get confused.
// We can differentiate them by `type` field.
model Invoice {
  id                      String                    @id @default(cuid())
  createdAt               DateTime                  @default(now()) @map("created_at")
  updatedAt               DateTime                  @default(now()) @updatedAt @map("updated_at")
  convertedAt             DateTime?                 @map("converted_at")
  deliveredAt             DateTime?                 @map("delivered_at")
  completedAt             DateTime?                 @map("completed_at")
  type                    InvoiceType               @default(Invoice)
  clientId                Int?                      @map("customer_id")
  vehicleId               Int?                      @map("vehicle_id")
  subtotal                Decimal?                  @default(0) @db.Decimal(8, 2)
  discount                Decimal?                  @default(0) @db.Decimal(8, 2)
  tax                     Decimal?                  @default(0) @db.Decimal(8, 2)
  serviceFee              Decimal?                  @default(0) @db.Decimal(8, 2)
  grandTotal              Decimal?                  @default(0) @map("grand_total") @db.Decimal(8, 2)
  deposit                 Decimal?                  @default(0) @db.Decimal(8, 2)
  due                     Decimal?                  @default(0) @db.Decimal(8, 2)
  statusId                Int?                      @map("status_id")
  fleetStatementId        String?
  internalNotes           String?
  dueDate                 String?
  terms                   String?
  policy                  String?
  customerNotes           String?
  customerComments        String?
  companyId               Int                       @map("company_id")
  userId                  Int?                      @map("user_id")
  assignedToId            Int?                      @map("assigned_to")
  fromRequest             Boolean?                  @default(false) @map("from_request")
  fromRequestedCompanyId  Int?                      @map("from_requested_company_id")
  requestEstimateId       Int?                      @unique @map("request_estimate_id")
  columnId                Int?                      @map("column_id")
  profit                  Int?                      @default(0)
  authorizedName          String?
  stripePaymentLink       String?                   @db.Text
  isWorkOrder             Boolean?                  @default(false) @map("is_work_order")
  workOrderCreatedAt      DateTime?                 @map("work_order_created_at")
  company                 Company                   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  invoiceItems            InvoiceItem[]
  vehicleParts            VehicleParts[]
  photos                  InvoicePhoto[]
  tasks                   Task[]
  status                  Status?                   @relation(fields: [statusId], references: [id])
  payments                Payment[]
  user                    User?                     @relation(name: "user", fields: [userId], references: [id], onDelete: SetNull)
  Material                Material[]
  InventoryProductHistory InventoryProductHistory[]
  vehicle                 Vehicle?                  @relation(fields: [vehicleId], references: [id])
  client                  Client?                   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  technician              Technician[]
  tags                    InvoiceTags[]
  requestEstimate         RequestEstimate?          @relation(fields: [requestEstimateId], onDelete: SetNull, references: [id])
  assignedTo              User?                     @relation(name: "assignedTo", fields: [assignedToId], references: [id], onDelete: SetNull)
  column                  Column?                   @relation(fields: [columnId], references: [id], onDelete: SetNull)
  InvoiceRedo             InvoiceRedo[]
  serviceIndex            Json?
  Inspections             InvoiceInspection[]
  totalPayment            Decimal?                  @default(0) @map("total_payment") @db.Decimal(8, 2)
  damageNotes             String?                   @map("damage_notes")
  columnChangedAt         DateTime?                 @map("column_changed_at")
  stripePayments          StripePayment[]
  TimeDelayExecution      TimeDelayExecution[]
  Refund                  Refund[]
  FleetStatement          FleetStatement?           @relation(fields: [fleetStatementId], references: [id])

  @@index([companyId], name: "fk_invoices_company")
  @@index([companyId, type])
}

model InvoiceTags {
  id        Int      @id @default(autoincrement())
  invoiceId String   @map("invoice_id")
  tagId     Int      @map("tag_id")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")
  invoice   Invoice  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  tag       Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@index([invoiceId], name: "fk_invoice_tags_invoice")
  @@index([tagId], name: "fk_invoice_tags_tag")
}

enum InvoiceType {
  Invoice
  Estimate
}

// Photo of a invoice.
// One invoice can have multiple photos.
model InvoicePhoto {
  id        Int      @id @default(autoincrement())
  invoiceId String   @map("invoice_id")
  photo     String   @db.VarChar(1024)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")
  invoice   Invoice  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@index([invoiceId], name: "fk_invoice_photos_invoice")
}

model RequestEstimate {
  id                Int      @id @default(autoincrement())
  senderId          Int      @map("sender_id")
  senderCompanyId   Int      @map("sender_company_id")
  receiverId        Int      @map("receiver_id")
  receiverCompanyId Int      @map("receiver_company_id")
  vehicleId         Int      @unique @map("vehicle_id")
  serviceId         Int      @unique @map("service_id")
  invoiceId         String   @map("invoice_id")
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @default(now()) @updatedAt @map("updated_at")
  sender            User     @relation("Sender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver          User     @relation("Receiver", fields: [receiverId], references: [id], onDelete: Cascade)
  senderCompany     Company  @relation("SenderCompany", fields: [senderCompanyId], references: [id], onDelete: Cascade)
  receiverCompany   Company  @relation("ReceiverCompany", fields: [receiverCompanyId], references: [id], onDelete: Cascade)
  invoice           Invoice?
  vehicle           Vehicle? @relation("Vehicle", fields: [vehicleId], references: [id], onDelete: Cascade)
  service           Service? @relation("Service", fields: [serviceId], references: [id], onDelete: Cascade)
  message           Message? @relation("Message")
}

// Technician of a InvoiceItem.
// One InvoiceItem can have multiple technicians.
model Technician {
  id            Int       @id @default(autoincrement())
  userId        Int       @map("user_id")
  date          DateTime? @map("assigned_date")
  dateClosed    DateTime? @map("date_closed")
  due           DateTime? @default(now())
  amount        Decimal?  @default(0)
  priority      Priority? @default(Low)
  status        String?
  note          String?   @map("new_note")
  serviceId     Int       @map("service_id")
  invoiceId     String    @map("invoice_id")
  companyId     Int       @map("company_id")
  invoiceItemId Int       @map("invoice_item_id")

  createdAt    DateTime       @default(now()) @map("created_at")
  updatedAt    DateTime       @default(now()) @updatedAt @map("updated_at")
  vehicleParts VehicleParts[]
  user         User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  service      Service?       @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  invoice      Invoice?       @relation(fields: [invoiceId], references: [id])
  company      Company        @relation(fields: [companyId], references: [id], onDelete: Cascade)
  InvoiceRedo  InvoiceRedo[]
  invoiceItem  InvoiceItem    @relation(fields: [invoiceItemId], references: [id], onDelete: Cascade)
}

model InvoiceRedo {
  id           Int      @id @default(autoincrement())
  invoiceId    String   @map("invoice_id")
  serviceId    Int      @map("service_id")
  technicianId Int      @map("technician_id")
  notes        String?
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @default(now()) @updatedAt @map("updated_at")

  invoice    Invoice    @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  service    Service    @relation(fields: [serviceId], references: [id])
  technician Technician @relation(fields: [technicianId], references: [id])
}

//model for inspection of a invoice.
model InvoiceInspection {
  id        Int      @id @default(autoincrement())
  invoiceId String   @map("invoice_id")
  title     String
  driver    Boolean  @default(false)
  passenger Boolean  @default(false)
  notes     String?
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")
  invoice   Invoice  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@index([invoiceId], name: "fk_invoice_inspections_invoice")
}

// Message for chat.
model Message {
  id                Int              @id @default(autoincrement())
  to                Int?
  message           String
  from              Int
  groupId           Int?             @map("group_id")
  section           MessageSection?
  requestEstimateId Int?             @unique @map("request_estimate_id")
  createdAt         DateTime         @default(now()) @map("created_at")
  updatedAt         DateTime         @default(now()) @updatedAt @map("updated_at")
  group             Group?           @relation(fields: [groupId], references: [id])
  attachment        Attachment[]
  requestEstimate   RequestEstimate? @relation("Message", fields: [requestEstimateId], references: [id])
  chatTrack         ChatTrack?

  @@index([to], name: "fk_messages_to")
  @@index([from], name: "fk_messages_from")
  @@index([groupId], name: "fk_messages_group")
}

enum MessageSection {
  internal
  collaboration
}

model ChatTrack {
  id          Int             @id @default(autoincrement())
  lastMessage String
  isRead      Boolean         @default(false)
  section     MessageSection?
  senderId    Int?            @map("sender_id")
  receiverId  Int?            @map("receiver_id")
  messageId   Int?            @unique @map("message_id")
  message     Message?        @relation(fields: [messageId], references: [id])
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @default(now()) @updatedAt @map("updated_at")
}

model Attachment {
  id        Int      @id @default(autoincrement())
  fileName  String // File name (e.g., 'image.png')
  fileType  String // File type (e.g., 'image/png', 'application/pdf')
  fileUrl   String // File storage path or URL
  fileSize  String
  messageId Int // Foreign key to Message model, enforces one-to-one relationship
  message   Message  @relation(fields: [messageId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")
}

model Group {
  id        Int       @id @default(autoincrement())
  name      String
  type      String    @default("Group")
  users     User[]    @relation("UserGroups")
  messages  Message[]
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @default(now()) @updatedAt @map("updated_at")
}

// notification settings model
model NotificationSettingsV2 {
  id                Int                 @id @default(autoincrement())
  companyId         Int                 @map("company_id")
  userId            Int                 @map("user_id")
  section           NotificationSection
  notification_type NotificationType
  email_enabled     Boolean             @default(false) @map("email_enabled")
  push_enabled      Boolean             @default(false) @map("push_enabled")
  text_enabled      Boolean             @default(false) @map("text_enabled")
  last_updated      DateTime            @default(now()) @map("last_updated")
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  company           Company             @relation(fields: [companyId], references: [id], onDelete: Cascade)
  user              User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, notification_type], name: "user_notification_type")
}

enum NotificationType {
  TASK_ASSIGNED
  TASK_FINISHED
  APPOINTMENT_CREATED
  APPOINTMENT_REMINDER
  APPOINTMENT_UPDATED
  TASK_REMINDER
  LEADS_GENERATED
  LEADS_CLOSED
  FOLLOW_UP
  LEADS_ASSIGNED
  STAGE
  ESTIMATE_CREATED
  INVOICE_CREATED
  INVOICE_DELIVERY
  INVOICE_CONVERTED
  INVOICE_AUTHORIZED
  PAYMENT_RECEIVED
  PAYMENT_DUE
  DEPOSIT
  WORK_ORDER_CREATED
  WORK_ORDER_COMPLETED
  DUE_DATE_PROXIMITY
  INVENTORY_COMPLETELY_OUT
  INVENTORY_NEWLY_ADDED
  INVENTORY_LOW
  LEAVE_REQUEST
  PERFORMANCE_CHANGES
  LATE_ARRIVALS
  EARLY_LEAVE
  JOB_COMPLETED
  JOB_ASSIGNED
  INTERNAL_MESSAGE_ALERT
  CLIENT_MESSAGE_ALERT
  CLIENT_CALL_ALERT
  CLIENT_EMAIL_ALERT
  COLLABORATION_MESSAGE_ALERT
}

enum NotificationSection {
  CALENDAR_AND_TASK
  LEAD_GENERATED_AND_SALES_PIPELINE
  ESTIMATE_AND_INVOICE
  PAYMENT
  OPERATION_PIPELINE
  INVENTORY
  WORK_FORCE
  COMMUNICATIONS
}

model Notification {
  id          Int      @id @default(autoincrement())
  userId      Int      @map("user_id")
  companyId   Int      @map("company_id")
  type        String?
  title       String
  description String
  isUnRead    Boolean  @default(true) @map("is_unread")
  avatarUrl   String?
  redirectUrl String?
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @default(now()) @updatedAt @map("updated_at")
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  company     Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
}

// Payment of a invoice.
// One invoice can have one payment. And one payment can't be in multiple invoices.
// Payment can be of type card, check, cash or other.
// If payment type is other, then it can have a payment method.
// If payment type is card, then it can have a card type.
model Payment {
  id              Int             @id @default(autoincrement())
  date            DateTime?
  notes           String?
  amount          Decimal? // Original payment amount
  refundedAmount  Decimal?        @default(0) @map("refunded_amount")
  refundMethod    PaymentType?    @map("refund_method")
  refundReason    String?         @map("refund_reason")
  type            PaymentType
  card            CardPayment?
  check           CheckPayment?
  cash            CashPayment?
  other           OtherPayment?
  deposit         DepositPayment?
  invoiceId       String?         @map("invoice_id")
  companyId       Int             @map("company_id")
  refundCreatedAt DateTime?       @map("refund_created_at")
  refundUpdatedAt DateTime?       @map("refund_updated_at")
  createdAt       DateTime        @default(now()) @map("created_at")
  updatedAt       DateTime        @default(now()) @updatedAt @map("updated_at")
  invoice         Invoice?        @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  Company         Company?        @relation(fields: [companyId], references: [id])
  stripePayment   StripePayment?
  Refund          Refund[]

  @@index([companyId])
  @@index([invoiceId])
  @@index([date])
  @@index([amount])
}

model Refund {
  id         Int         @id @default(autoincrement())
  amount     Decimal     @db.Decimal(8, 2)
  reason     String?
  method     PaymentType // How the refund was processed (CASH, CARD, etc.)
  refundDate DateTime    @default(now()) @map("refund_date")
  notes      String?

  // Foreign keys
  paymentId   Int    @map("payment_id")
  invoiceId   String @map("invoice_id")
  companyId   Int    @map("company_id")
  processedBy Int?   @map("processed_by") // User who processed the refund

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  // Relations
  payment Payment @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  invoice Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  user    User?   @relation(fields: [processedBy], references: [id], onDelete: SetNull)

  @@map("refunds")
}

model CardPayment {
  id         Int      @id @default(autoincrement())
  paymentId  Int      @unique
  creditCard String?
  cardType   CardType
  payment    Payment  @relation(fields: [paymentId], references: [id], onDelete: Cascade)
}

model CheckPayment {
  id          Int     @id @default(autoincrement())
  paymentId   Int     @unique
  checkNumber String?
  payment     Payment @relation(fields: [paymentId], references: [id], onDelete: Cascade)
}

model CashPayment {
  id           Int     @id @default(autoincrement())
  paymentId    Int     @unique
  receivedCash String?
  payment      Payment @relation(fields: [paymentId], references: [id], onDelete: Cascade)
}

model OtherPayment {
  id              Int            @id @default(autoincrement())
  paymentId       Int            @unique
  paymentMethodId Int?
  payment         Payment        @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  paymentMethod   PaymentMethod? @relation(fields: [paymentMethodId], references: [id], onDelete: Cascade)
}

model DepositPayment {
  id            Int     @id @default(autoincrement())
  paymentId     Int     @unique
  depositMethod String?
  depositNotes  String?
  payment       Payment @relation(fields: [paymentId], references: [id], onDelete: Cascade)
}

model StripePayment {
  id                    Int      @id @default(autoincrement())
  stripePaymentIntentId String   @unique @map("stripe_payment_intent_id")
  paymentId             Int      @unique @map("payment_id")
  payment               Payment  @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  invoiceId             String?  @map("invoice_id")
  invoice               Invoice? @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  companyId             Int      @map("company_id")
  createdAt             DateTime @default(now()) @map("created_at")
  updatedAt             DateTime @default(now()) @updatedAt @map("updated_at")
  company               Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
}

model PaymentMethod {
  id        Int            @id @default(autoincrement())
  name      String
  companyId Int            @map("company_id")
  createdAt DateTime       @default(now()) @map("created_at")
  updatedAt DateTime       @default(now()) @updatedAt @map("updated_at")
  payments  OtherPayment[]
  company   Company        @relation(fields: [companyId], references: [id], onDelete: Cascade)
}

enum PaymentType {
  CARD
  CHECK
  CASH
  OTHER
  DEPOSIT
}

enum CardType {
  MASTERCARD
  VISA
  AMEX
  OTHER
}

model Coupon {
  id           Int            @id @default(autoincrement())
  name         String
  code         String
  type         String
  startDate    DateTime
  endDate      DateTime
  discount     Decimal
  discountType DiscountType
  status       CouponStatus
  redemptions  Int
  companyId    Int            @map("company_id")
  createdAt    DateTime       @default(now()) @map("created_at")
  updatedAt    DateTime       @default(now()) @updatedAt @map("updated_at")
  company      Company        @relation(fields: [companyId], references: [id], onDelete: Cascade)
  ClientCoupon ClientCoupon[]
}

enum CouponStatus {
  Active
  Expired
}

enum DiscountType {
  Percentage
  Fixed
}

// Task for a company.
model Task {
  id            Int        @id @default(autoincrement())
  title         String     @db.VarChar(100)
  description   String?
  date          DateTime?
  startTime     String?    @map("start_time")
  endTime       String?    @map("end_time")
  priority      Priority
  taskUser      TaskUser[]
  createdAt     DateTime   @default(now()) @map("created_at")
  updatedAt     DateTime   @default(now()) @updatedAt @map("updated_at")
  userId        Int        @map("user_id")
  companyId     Int        @map("company_id")
  invoiceId     String?    @map("invoice_id")
  user          User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  company       Company    @relation(fields: [companyId], references: [id], onDelete: Cascade)
  Invoice       Invoice?   @relation(fields: [invoiceId], references: [id])
  clientId      Int?       @map("client_id")
  client        Client?    @relation(fields: [clientId], references: [id])
  googleEventId String?
  leadId        Int?       @map("lead_id")
  lead          Lead?      @relation(fields: [leadId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([companyId])
}

// Assigned user for a task.
// One task can have multiple users.
model TaskUser {
  id        Int      @id @default(autoincrement())
  taskId    Int      @map("task_id")
  userId    Int      @map("user_id")
  eventId   String?  @db.VarChar(100)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")
  task      Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([taskId])
}

model UserFeedback {
  id                     Int                      @id @default(autoincrement())
  userId                 Int                      @map("user_id")
  companyId              Int                      @map("company_id")
  whatHappened           String
  whatExpected           String
  snapshotImage          String?
  createdAt              DateTime                 @default(now()) @map("created_at")
  updatedAt              DateTime                 @default(now()) @updatedAt @map("updated_at")
  user                   User                     @relation(fields: [userId], references: [id], onDelete: Cascade)
  UserFeedbackAttachment UserFeedbackAttachment[]
  company                Company                  @relation(fields: [companyId], references: [id])
}

model UserFeedbackAttachment {
  id             Int          @id @default(autoincrement())
  fileName       String
  userFeedbackId Int          @map("user_feedback_id")
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @default(now()) @updatedAt @map("updated_at")
  userFeedback   UserFeedback @relation(fields: [userFeedbackId], references: [id])
}

// User model.
// User can be employee or admin.
// When user registers, they have to create a company. So, every new user is an admin.
// After that, they can add employees to the company.
model User {
  id                Int                @id @default(autoincrement())
  firstName         String
  lastName          String?
  email             String             @unique
  emailVerifiedAt   DateTime?          @map("email_verified_at")
  image             String             @default("/images/default.png")
  password          String
  provider          Provider           @default(email)
  timezone          String             @default("UTC")
  phone             String?
  address           String?
  city              String?
  state             String?
  zip               String?
  companyName       String?            @map("company_name")
  commission        Decimal?           @default(0) @db.Decimal(10, 3)
  role              Role               @default(admin)
  employeeType      EmployeeType       @default(Admin)
  joinDate          DateTime?          @map("join_date")
  companyId         Int                @map("company_id")
  createdAt         DateTime           @default(now()) @map("created_at")
  updatedAt         DateTime           @default(now()) @updatedAt @map("updated_at")
  company           Company            @relation(fields: [companyId], references: [id], onDelete: Cascade)
  groups            Group[]            @relation("UserGroups")
  tasks             Task[]
  taskUsers         TaskUser[]
  appointments      Appointment[]
  appointmentUsers  AppointmentUser[]
  invoices          Invoice[]          @relation("user")
  Technician        Technician[]
  permissions       Permission[]
  assignedInvoices  Invoice[]          @relation("assignedTo")
  LeaveRequest      LeaveRequest[]
  sentEstimates     RequestEstimate[]  @relation("Sender")
  receivedEstimates RequestEstimate[]  @relation("Receiver")
  OAuthToken        OAuthToken?
  ClockInOut        ClockInOut[]
  UserFeedback      UserFeedback[]
  inventoryProducts InventoryProduct[]
  ClientSMS         ClientSMS[]
  ClientCall        ClientCall[]

  salesLead            Lead[]
  NotificationSettings NotificationSettingsV2[]
  Notification         Notification[]
  resetToken           PasswordResetToken?
  Refund               Refund[]

  @@index([companyId], name: "fk_users_company")
}

model PasswordResetToken {
  id        String   @id @default(uuid())
  token     String   @unique
  otp       String
  user      User     @relation(fields: [userId], references: [id])
  userId    Int      @unique @map("user_id")
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
}

// OAuth token for user.
// This is mainly used for google calendar integration.
model OAuthToken {
  id           Int       @id @default(autoincrement())
  userId       Int       @unique @map("user_id")
  provider     String
  accessToken  String    @map("access_token")
  refreshToken String?   @map("refresh_token")
  expiresIn    DateTime? @map("expires_in")
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @default(now()) @updatedAt @map("updated_at")
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId], name: "fk_oauth_tokens_user")
}

enum Provider {
  google
  apple
  email
}

enum Role {
  admin
  employee
}

enum EmployeeType {
  Admin
  Manager
  Sales
  Technician
  Other
}

model PermissionForManager {
  id                            Int     @id @default(autoincrement())
  companyId                     Int     @map("company_id")
  communicationHubInternal      Boolean @default(true) @map("communication_hub_internal")
  communicationHubClients       Boolean @default(true) @map("communication_hub_clients")
  communicationHubCollaboration Boolean @default(true) @map("communication_hub_collaboration")
  estimatesInvoices             Boolean @default(true) @map("estimates_invoices")
  calendarTask                  Boolean @default(true) @map("calendar_task")
  payments                      Boolean @default(true)
  workforceManagement           Boolean @default(true) @map("workforce_management")
  reporting                     Boolean @default(true)
  inventoryAll                  Boolean @default(true)
  integrations                  Boolean @default(false)
  salesPipeline                 Boolean @default(true) @map("sales_pipeline")
  shopPipeline                  Boolean @default(true) @map("shop_pipeline")
  businessSettings              Boolean @default(false) @map("business_settings")

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
}

model PermissionForSales {
  id                            Int     @id @default(autoincrement())
  companyId                     Int     @map("company_id")
  communicationHubInternal      Boolean @default(true) @map("communication_hub_internal")
  communicationHubClients       Boolean @default(true) @map("communication_hub_clients")
  communicationHubCollaboration Boolean @default(true) @map("communication_hub_collaboration")
  estimatesInvoices             Boolean @default(true) @map("estimates_invoices")
  calendarTask                  Boolean @default(true) @map("calendar_task")
  payments                      Boolean @default(false)
  salesPipeline                 Boolean @default(true) @map("sales_pipeline")

  //view only
  workforceManagementViewOnly Boolean @default(true) @map("workforce_management")
  reportingViewOnly           Boolean @default(true)
  inventoryAllViewOnly        Boolean @default(true)

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
}

model PermissionForTechnician {
  id                       Int     @id @default(autoincrement())
  companyId                Int     @map("company_id")
  communicationHubInternal Boolean @default(true) @map("communication_hub_internal")
  calendarTask             Boolean @default(true) @map("calendar_task")
  shopPipeline             Boolean @default(true) @map("shop_pipeline")

  //view only
  workforceManagementViewOnly Boolean @default(true) @map("workforce_management")
  reportingViewOnly           Boolean @default(true)

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
}

model PermissionForOther {
  id                            Int     @id @default(autoincrement())
  companyId                     Int     @map("company_id")
  communicationHubInternal      Boolean @default(false) @map("communication_hub_internal")
  communicationHubClients       Boolean @default(false) @map("communication_hub_clients")
  communicationHubCollaboration Boolean @default(false) @map("communication_hub_collaboration")
  estimatesInvoices             Boolean @default(false) @map("estimates_invoices")
  calendarTask                  Boolean @default(false) @map("calendar_task")
  payments                      Boolean @default(false)
  workforceManagement           Boolean @default(false) @map("workforce_management")
  reporting                     Boolean @default(false)
  inventoryAll                  Boolean @default(false)
  integrations                  Boolean @default(false)
  salesPipeline                 Boolean @default(false) @map("sales_pipeline")
  shopPipeline                  Boolean @default(false) @map("shop_pipeline")
  businessSettings              Boolean @default(false) @map("business_settings")

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
}

model Permission {
  id                            Int     @id @default(autoincrement())
  userId                        Int     @map("user_id")
  companyId                     Int     @map("company_id")
  communicationHubInternal      Boolean @default(false) @map("communication_hub_internal")
  communicationHubClients       Boolean @default(false) @map("communication_hub_clients")
  communicationHubCollaboration Boolean @default(false) @map("communication_hub_collaboration")
  estimatesInvoices             Boolean @default(false) @map("estimates_invoices")
  calendarTask                  Boolean @default(false) @map("calendar_task")
  payments                      Boolean @default(false)
  workforceManagement           Boolean @default(false) @map("workforce_management")
  reporting                     Boolean @default(false)
  inventory                     Boolean @default(false)
  integrations                  Boolean @default(false)
  salesPipeline                 Boolean @default(false) @map("sales_pipeline")
  shopPipeline                  Boolean @default(false) @map("shop_pipeline")
  businessSettings              Boolean @default(false) @map("business_settings")

  // View-only fields
  workforceManagementViewOnly Boolean @default(false) @map("workforce_management_view_only")
  reportingViewOnly           Boolean @default(false) @map("reporting_view_only")
  inventoryAllViewOnly        Boolean @default(false) @map("inventory_all_view_only")

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([userId, companyId])
}

model ClockInOut {
  id        Int       @id @default(autoincrement())
  userId    Int       @map("user_id")
  companyId Int       @map("company_id")
  clockIn   DateTime  @map("clock_in")
  clockOut  DateTime? @map("clock_out")
  timezone  String?
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @default(now()) @updatedAt @map("updated_at")

  user       User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  company    Company      @relation(fields: [companyId], references: [id], onDelete: Cascade)
  ClockBreak ClockBreak[]

  @@index([userId], name: "fk_clock_in_out_user")
  @@index([companyId], name: "fk_clock_in_out_company")
}

// breaks model ofr clockinout
model ClockBreak {
  id           Int       @id @default(autoincrement())
  clockInOutId Int       @map("clock_in_out_id")
  breakStart   DateTime  @map("break_start")
  breakEnd     DateTime? @map("break_end")
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @default(now()) @updatedAt @map("updated_at")

  clockInOut ClockInOut @relation(fields: [clockInOutId], references: [id], onDelete: Cascade)

  @@index([clockInOutId], name: "fk_clock_break_clock_in_out")
}

model ClientSMS {
  id          Int                    @id @default(autoincrement())
  message     String                 @db.Text
  from        String
  to          String
  sentBy      ClientSMSSentBy
  isRead      Boolean                @default(false) @map("is_read")
  userId      Int?                   @map("user_id")
  companyId   Int                    @map("company_id")
  clientId    Int                    @map("client_id")
  attachments ClientSmsAttachments[]

  client  Client  @relation(fields: [clientId], references: [id], onDelete: Cascade)
  user    User?   @relation(fields: [userId], references: [id], onDelete: Cascade)
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")
}

model ClientCall {
  id            Int             @id @default(autoincrement())
  callSid       String          @unique // Twilio's unique call ID
  from          String // Caller number
  to            String // Recipient number
  status        String? // Call status (e.g., completed, failed)
  direction     String? // inbound or outbound
  duration      Int? // Duration in seconds
  recordingUrl  String? // Recording file URL (if applicable)
  recordingSid  String? // Twilio's unique recording ID
  callStartTime DateTime? // Start time
  callEndTime   DateTime? // End time
  sentBy        ClientSMSSentBy // Enum you already use
  userId        Int?            @map("user_id")
  companyId     Int             @map("company_id")
  clientId      Int             @map("client_id")

  client  Client  @relation(fields: [clientId], references: [id], onDelete: Cascade)
  user    User?   @relation(fields: [userId], references: [id], onDelete: Cascade)
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")
}

model ClientSmsAttachments {
  id   Int    @id @default(autoincrement())
  name String
  url  String

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  clientSMSId Int       @map("client_sms_id")
  clientSMS   ClientSMS @relation(fields: [clientSMSId], references: [id], onDelete: Cascade)
}

enum ClientSMSSentBy {
  Client
  Company
}

// Vehicle of a company.
model Vehicle {
  id                     Int      @id @default(autoincrement())
  year                   Int?
  make                   String?
  model                  String?
  submodel               String?
  type                   String?
  transmission           String?
  engineSize             String?
  license                String?
  vin                    String?
  notes                  String?
  other                  String?  @db.Text
  fromRequest            Boolean? @default(false) @map("from_request")
  fromRequestedCompanyId Int?     @map("from_requested_company_id")

  colorId         Int?             @map("color_id")
  clientId        Int?             @map("customer_id")
  companyId       Int              @map("company_id")
  createdAt       DateTime         @default(now()) @map("created_at")
  updatedAt       DateTime         @default(now()) @updatedAt @map("updated_at")
  company         Company          @relation(fields: [companyId], references: [id], onDelete: Cascade)
  appointments    Appointment[]
  color           VehicleColor?    @relation(fields: [colorId], references: [id], onDelete: SetNull)
  client          Client?          @relation(fields: [clientId], references: [id], onDelete: Cascade)
  invoices        Invoice[]
  requestEstimate RequestEstimate? @relation("Vehicle")

  @@index([companyId], name: "fk_vehicles_company")
}

model VehicleColor {
  id        Int       @id @default(autoincrement())
  name      String
  companyId Int       @map("company_id")
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @default(now()) @updatedAt @map("updated_at")
  Vehicle   Vehicle[]
  company   Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
}

model VehicleParts {
  id           Int         @id @default(autoincrement())
  partsName    String
  technicianId Int?        @map("technician_id")
  invoiceId    String      @map("invoice_id")
  serviceId    Int?        @map("service_id")
  createdAt    DateTime    @default(now()) @map("created_at")
  updatedAt    DateTime    @default(now()) @updatedAt @map("updated_at")
  technician   Technician? @relation(fields: [technicianId], references: [id], onDelete: Cascade)
  invoice      Invoice?    @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  service      Service?    @relation(fields: [serviceId], references: [id], onDelete: Cascade)
}
